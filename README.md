# AltaSoft.Choice

[![NuGet - AltaSoft.Choice](https://img.shields.io/nuget/v/AltaSoft.Choice?label=AltaSoft.Choice)](https://www.nuget.org/packages/AltaSoft.Choice)
[![NuGet - AltaSoft.Choice.Generator](https://img.shields.io/nuget/v/AltaSoft.Choice.Generator?label=AltaSoft.Choice.Generator)](https://www.nuget.org/packages/AltaSoft.Choice.Generator)
[![Dot NET 8+](https://img.shields.io/static/v1?label=DOTNET&message=8%2B&color=0c3c60&style=for-the-badge)](https://dotnet.microsoft.com)

**AltaSoft.ChoiceGenerator** is a lightweight C# source generator that allows you to define *choice types* (discriminated unions) with minimal syntax.

---

## ✨ Features

- Simple `[Choice]` attribute for defining alternatives
- Generates type-safe properties
- Supports XML and System.Text.Json serialization
- Includes `CreateAsXxx`, `Match`, and `Switch` methods
- Auto-generates enum for valid choice types
- Implicit conversion operators for easy usage
- Generates XmlSerializer

---

## 🛠️ Installation

Add the following NuGet packages to your project:

```xml
<ItemGroup>
  <PackageReference Include="AltaSoft.Choice" Version="x.x.x" />
  <PackageReference Include="AltaSoft.Choice.Generator" Version="x.x.x" PrivateAssets="all" />
</ItemGroup>
```

---

## ✅ Define Your Choice Type

Mark your class with `[Choice]` and define **partial nullable properties** :

```csharp
using AltaSoft.Choice;
namespace AltaSoft.ChoiceGenerator.Tests;

[Choice]
public sealed partial class Authorisation1Choice
{
    /// <summary>
    /// <para>Specifies the authorisation, in a coded form.</para>
    /// </summary>
    [XmlTag("Cd")]
    [JsonPropertyName("cd")]
    public partial Authorisation1Code? Code { get; set; }

    /// <summary>
    /// <para>Specifies the authorisation, in a free text form.</para>
    /// </summary>
    [XmlTag("Prtry")]
    public partial Proprietary? Proprietary { get; set; }
}
```

---

## ⚙️ Generated Code

Below is the generated code for the example above:

```csharp
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by 'AltaSoft Choice.Generator'.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using AltaSoft.ChoiceGenerator.Tests;
using AltaSoft.Choice;
using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Schema;

namespace AltaSoft.ChoiceGenerator.Tests;

#pragma warning disable CS8774 // Member must have a non-null value when exiting.
#pragma warning disable CS0628 // New protected member declared in sealed type

public sealed partial class Authorisation1Choice : IXmlSerializable
{
    /// <summary>
    /// <para>Choice enum </para>
    /// </summary>
    [JsonIgnore]
    public ChoiceOf ChoiceType { get; private set; }

    private AltaSoft.ChoiceGenerator.Tests.Authorisation1Code? _code;

    /// <summary>
    /// Specifies the authorisation, in a coded form.
    /// </summary>
    [DisallowNull]
    public partial AltaSoft.ChoiceGenerator.Tests.Authorisation1Code? Code
    {
        get => _code;
        set
        {
            _code = value ?? throw new InvalidOperationException("Choice value cannot be null");
            _proprietary = null;
            ChoiceType = ChoiceOf.Code;
        }
    }

    private static readonly XmlSerializer s_codeSerializer = new (typeof(AltaSoft.ChoiceGenerator.Tests.Authorisation1Code), new XmlRootAttribute("Cd"));
    private Proprietary? _proprietary;

    /// <summary>
    /// Specifies the authorisation, in a free text form.
    /// </summary>
    [DisallowNull]
    public partial Proprietary? Proprietary
    {
        get => _proprietary;
        set
        {
            _proprietary = value ?? throw new InvalidOperationException("Choice value cannot be null");
            _code = null;
            ChoiceType = ChoiceOf.Proprietary;
        }
    }

    private static readonly XmlSerializer s_proprietarySerializer = new (typeof(Proprietary), new XmlRootAttribute("Prtry"));

    /// <summary>
    /// Creates a new <see cref="AltaSoft.ChoiceGenerator.Tests.Authorisation1Choice"/> instance and sets its value using the specified <see cref="AltaSoft.ChoiceGenerator.Tests.Authorisation1Code"/>.
    /// </summary>
    /// <param name="value">The value to assign to the created choice instance.</param>
    public static AltaSoft.ChoiceGenerator.Tests.Authorisation1Choice CreateAsCode(AltaSoft.ChoiceGenerator.Tests.Authorisation1Code value) => new () { Code = value };

    /// <summary>
    /// Creates a new <see cref="AltaSoft.ChoiceGenerator.Tests.Authorisation1Choice"/> instance and sets its value using the specified <see cref="Proprietary"/>.
    /// </summary>
    /// <param name="value">The value to assign to the created choice instance.</param>
    public static AltaSoft.ChoiceGenerator.Tests.Authorisation1Choice CreateAsProprietary(Proprietary value) => new () { Proprietary = value };

    /// <summary>
    /// <para>Applies the appropriate function based on the current choice type</para>
    /// </summary>
    /// <typeparam name="TResult">The return type of the provided match functions</typeparam>
    /// <param name="matchCode">Function to invoke if the choice is a <see cref="ChoiceOf.Code"/> value</param>
    /// <param name="matchProprietary">Function to invoke if the choice is a <see cref="ChoiceOf.Proprietary"/> value</param>
    public TResult Match<TResult>(
    	Func<AltaSoft.ChoiceGenerator.Tests.Authorisation1Code, TResult> matchCode, 
    	Func<Proprietary, TResult> matchProprietary)
    {
        return ChoiceType switch
        {
            ChoiceOf.Code => matchCode(Code!.Value),
            ChoiceOf.Proprietary => matchProprietary(Proprietary!),
            _ => throw new InvalidOperationException($"Invalid ChoiceType. '{ChoiceType}'")
        };
    }

    /// <summary>
    /// <para>Applies the appropriate Action based on the current choice type</para>
    /// </summary>
    /// <param name="matchCode">Action to invoke if the choice is a <see cref="ChoiceOf.Code"/> value</param>
    /// <param name="matchProprietary">Action to invoke if the choice is a <see cref="ChoiceOf.Proprietary"/> value</param>
    public void Switch(
    	Action<AltaSoft.ChoiceGenerator.Tests.Authorisation1Code> matchCode, 
    	Action<Proprietary> matchProprietary)
    {
        switch (ChoiceType)
        {
            case ChoiceOf.Code:
                matchCode(Code!.Value);
                return;

            case ChoiceOf.Proprietary:
                matchProprietary(Proprietary!);
                return;

            default:
            throw new XmlException($"Invalid ChoiceType. '{ChoiceType}'");
        }
    }

    /// <inheritdoc/>
    public XmlSchema? GetSchema() => null;

    /// <inheritdoc/>
    public void ReadXml(XmlReader reader)
    {
        ArgumentNullException.ThrowIfNull(reader);

        reader.MoveToContent();

        if (reader.IsEmptyElement)
        	throw new XmlException("Authorisation1Choice element must contain exactly one of <Cd> or <Prtry>.");

        reader.ReadStartElement();

        var sawChoice = false;
        while (reader.MoveToContent() == XmlNodeType.Element)
        {
            if (sawChoice)
            	throw new XmlException("Authorisation1Choice must contain at most one of <Cd> or <Prtry>.");

            switch (reader.LocalName)
            {
                case "Cd":
                    Code = (AltaSoft.ChoiceGenerator.Tests.Authorisation1Code)(s_codeSerializer.Deserialize(reader) ?? throw new XmlException(" The value of Cd cannot be null"));
                    sawChoice = true;
                    break;

                case "Prtry":
                    Proprietary = (Proprietary)(s_proprietarySerializer.Deserialize(reader) ?? throw new XmlException(" The value of Prtry cannot be null"));
                    sawChoice = true;
                    break;

                default:
                    reader.Skip();
                    break;
            }
        }

        reader.ReadEndElement();

        if (!sawChoice)
        	throw new XmlException("Authorisation1Choice must contain exactly one of <Cd> or <Prtry>");
    }

    /// <inheritdoc/>
    public void WriteXml(XmlWriter writer)
    {
        ArgumentNullException.ThrowIfNull(writer);

        switch (ChoiceType)
        {
            case ChoiceOf.Code:
                s_codeSerializer.Serialize(writer, Code!, XmlNamespaceHelper.EmptyNamespace);
                break;

            case ChoiceOf.Proprietary:
                s_proprietarySerializer.Serialize(writer, Proprietary!, XmlNamespaceHelper.EmptyNamespace);
                break;

            default:
                throw new InvalidOperationException($"Invalid ChoiceType. '{ChoiceType}'");
        }
    }

    /// <summary>
    /// Implicitly converts an <see cref="AltaSoft.ChoiceGenerator.Tests.Authorisation1Code"/> to an <see cref="Authorisation1Choice"/>.
    /// </summary>
    /// <param name="value">The <see cref="AltaSoft.ChoiceGenerator.Tests.Authorisation1Code"/> to convert.</param>
    /// <returns>
    /// <see cref="Authorisation1Choice"/> instance representing the code.
    /// </returns>
    public static implicit operator Authorisation1Choice(AltaSoft.ChoiceGenerator.Tests.Authorisation1Code value) => CreateAsCode(value);

    /// <summary>
    /// Implicitly converts an <see cref="Proprietary"/> to an <see cref="Authorisation1Choice"/>.
    /// </summary>
    /// <param name="value">The <see cref="Proprietary"/> to convert.</param>
    /// <returns>
    /// <see cref="Authorisation1Choice"/> instance representing the code.
    /// </returns>
    public static implicit operator Authorisation1Choice(Proprietary value) => CreateAsProprietary(value);

    /// <summary>
    /// <para>Choice enumeration</para>
    /// </summary>
    [Serializable]
    public enum ChoiceOf
    {
        /// <summary>
        /// Specifies the authorisation, in a coded form.
        /// </summary>
        Code, 
        /// <summary>
        /// Specifies the authorisation, in a free text form.
        /// </summary>
        Proprietary, 
    }
}

```

---

## 💡 Example Usage

### Creating with CreateAs methods
```csharp
var choice = Authorisation1Choice.CreateAsCode(Authorisation1Code.FileLevelAuthorisationSummary);

var result = choice.Match(
    code => $"It's a code: {code}",
    prop => $"It's proprietary: {prop.ToString()}"
);

choice.Switch(
    code => Console.WriteLine($"String: {code}"),
    prop => Console.WriteLine($"Number: {prop.ToString()}")
);
```

### Creating using implicit operators

if property types are distinct implicit operators are generated
```csharp
Authosiration1Choice choice = Authorisation1Code.FileLevelAuthorisationSummary;
```

## Advanced Usage
### XML Serialization
By default XmlSerialzier is created for all property types however, for enum types you can use Custom methods that will be used to serialize and deserialize xml
```csharp
[Choice]
public sealed partial class Authorisation1Choice
{
    /// <summary>
    /// <para>Specifies the authorisation, in a coded form.</para>
    /// </summary>
    [XmlTag("Cd")]
    [JsonPropertyName("cd")]
    public partial Authorisation1Code? Code { get; set; }

    /// <summary>
    /// <para>Specifies the authorisation, in a free text form.</para>
    /// </summary>
    [XmlTag("Prtry")]
    public partial Proprietary? Proprietary { get; set; }

    /// <summary>
    /// Custom method to Deserialize enums from XML 
    /// </summary>
    private static Authorisation1Code StringToCode(string value) => Enum.Parse<Authorisation1Code>(value);
    /// <summary>
    /// Custom method to serialzie enum to XML
    /// </summary>
    private static string CodeToString(Authorisation1Code value) => value.ToString();

}
```
---

## 📦 Projects

- `AltaSoft.Choice`  
  Contains the `[Choice]` marker attribute

- `AltaSoft.Choice.Generator`  
  Implements the source generator that produces boilerplate code

---

## 📄 License

This project is licensed under the [MIT License](LICENSE).
